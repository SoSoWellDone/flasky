<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Summary Flask</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <article>
    <h1>Wstęp</h1>
    <h2>Jak pracować z przykładowym kodem</h2>
    <p>
        Repozytorium z historią zmian i przykładowymi kodami z książki:
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        Przełączanie między rewizjami, do tagu <em>1a</em>:
        <code>$ git chekout 1a</code>
        Będąc w stanie <strong>detached HEAD</strong> wprowadzone zmiany nie mają gdzie być
        zapisane. Resetowanie wprowadzonych zmian do wersji z commita:
        <code>$ git reset --hard</code>
        Synchronizowanie lokalnego repozytorium z originalnym z GitHuba:
        <code>$ git fetch --all</code>
        <code>$ git fetch --tags</code>
        <code>$ git reset --hard origin/master</code>
        Przegląd różnic występujących pomiędzy dwoma wersjami aplikacji:
        <code>$ git diff 2a 2b</code>
        Różnice między dwoma rewizjami na GitHubie:
        <code><a href="https://github.com/miguelgrinberg/flasky/compare/2a...2b">
            https://github.com/miguelgrinberg/flasky/compare/2a...2b
        </a></code>
    </p>
    </article>

    <article>
    <h1>Instalacja</h1>
    <h2>Tworzenie katalogu aplikacji</h2>
    <h3>Korzystając z klonu z GitHuba</h3>
    <p>
        <code>$ git clone https://github.com/miguelgrinberg/flasky.git</code>
        <code>$ cd flasky</code>
        <code>$ git checkout 1a</code>
    </p>
    <h3>Ograniczając się jedynie do lokalnego projektu</h3>
    <p>
        <code>$ mkdir flasky</code>
        <code>$ cd flasky</code>
    </p>
    <h2>Wirtualne środowiska</h2>
    <h3>Tworzenie wirtualnego środowiska w Python 3</h3>
    <p>
        Polecenie tworzące wirtualne środowisko o nazwie <em>.venv</em>:
        <code>$ python -m venv .venv</code>
    </p>
    <h3>Praca z wirtualnym środowiskiem</h3>
    <p>
        Aktywowanie wirtualnego środowiska:
        <code>$ source .venv/bin/activate  # w Linux</code>
        <code>&gt; .venv\Scripts\activate  # w Windows</code>
        Uruchamianie konsoli wirtualnego środowiska (w przypadku nie aktywowania wirtualnego
        środowiska):
        <code>$ .venv/bin/python  # w Linux</code>
        <code>&gt; venv\Sripts\python  # w Windows</code>
        Deaktywowanie wirtualnego środowiska:
        <code>$ deactivate  # w Linux</code>
        <code>&gt; deactivate  # w Windows</code>
    </p>
    <h2>Instalowanie pakietu Pythona</h2>
    <p>
        Instalacja pakietu <em>flask</em> oraz wszystkich jego zależności:
        <code>(.venv) $ pip install flask</code>
        Lista zainstalowanych pakietów:
        <code>(.venv) $ pip freeze</code>
        Proste sprawdzenie poprawności instalacji pakietu:
        <code>(.venv) $ python</code>
        <code>&gt;&gt;&gt; import flask</code>
        <code>&gt;&gt;&gt;</code>
    </p>
    </article>

    <article>
        <h1>Podstawowa struktura aplikacji</h1>


        <h2>Inicjalizacja</h2>
        <p>
            <span>Instancja aplikacji </span> jest obiektem klasy <span>Flask</span>

            <code>__name__</code> powrzechnie używana wartość
            <hr>
            <a href="#">Git</a>
        </p>
        <hr>
        <a href="#">Git</a>
    

        <h2>Trasy i funkcje widoku</h2>
        <p>
            Odwzorowanie adresów URL na funkcje Pythona (ang. <em lang="en">route</em>)
<pre>
@app.route('/')
def index():
    return "&lt;h1&gt;Hello, World!&lt;/h1&gt;"
</pre>
            Równoważny sposób rejestrowania funkcji widoku
            <pre>app.add_url_rule('/', 'index', index)</pre>
        </p>
        <p>
            Składnik dynamiczny adresu
<pre>
@app.route('/user/&lt;name&gt;')
def user(name):
    return f"&lt;h1&gt;Hello, {name}!&lt;/h1&gt;"
</pre>
            Dynamiczne komponenty w trasach mogą mieć różne typy
            <pre>&lt;name&gt; (lub &lt;string: name&gt; &mdash; wartość domyślna), &lt;int: id&gt;, &lt;float: f&gt;, &lt;path: p&gt;</pre>
        
            <hr>
            <a href="#">2_trasy_i_funkcje_widoku</a> ¤
            <a href="#">2_kompletna_app</a>
        </p>
    

        <h2>Roboczy serwer WWW</h2>
        <p>
            Uruchamianie serwera, najpierw ustawiamy zmienną środowiskową
            <code>(venv) $ export FLASK_APP=hello.py</code>
            <code>&gt; set FLASK_APP=hello.py  # Windows</code>
            <code>PS &gt $Env:FLASK_APP="hello.py"  # Windows PowerShell</code>
            <code>(venv) $ flask run</code>
            Inna metoda uruchamiania serwera
            <pre>app.run()</pre>
            Zatrzymanie serwera <kbd>Ctrl+C</kbd>
        </p>
        <p>
            Adres URL: <a href="http://localhost:5000">http://localhost:5000</a>
        </p>
        <p>
            W trybie debugowania serwer Flaska domyślnie włącza dwa moduły serwera:
            <em lang="en">reloader</em> i <em lang="en">debuger</em>
            <code>(venv) $ export FLASK_DEBUG=1</code>
            <code>PS &gt; $Env:FLASK_DEBUG=1  # Windows PowerShell</code>
            <code>(venv) $ flask run</code>
            W przypadku tradycyjnej metody uruchamiania serwera, moduł debugera włączamy>
            <pre>app.run(debug=True)</pre>
            Kodem PIN można zabezpieczyć przypadkowe uruchomienie debugera na serwerze produkcyjnym.
        </p>
        <p>
            Opcje wiersza poleceń polecenia <em>flask</em>
            <code>(venv) $ flask --help</code>
            Sesja powłoki Pythona w kontekście aplikacji
            <code>(venv) $ flask shell</code>
            Opcje wiersza poleceń polecenia <em>flask run</em>
            <code>(venv) $ flask run --help</code>
            Adres interfejsu sieciowego na jakim serwer nasłuchuje połączeń od klientów:<br>
            - domyślnie 127.0.0.1 (localhost), na tym samym komputerze
            <code>(venv) $ flask run</code>
            - w całej sieci, serwer widoczny pod adresem komputera
            na którym został uruchomiony <em>http://a.b.c.d:5000</em>
            <code>(venv) $ flask run --host 0.0.0.0</code>
        </p>

        <h2>Cykl żądanie - odpowiedź</h2>
        <p>
            Konteksty umożliwiają Flaskowi globalne udostępnianie wątkowi pewnych zmiennych
            bez ingerencji w inne wątki, tu na przykładzie obiektu <em>request</em>
<pre>
@app.route('/browser')
def browser():
    user_agent = request.headers.get('User-Agent')
    return f"&lt;p&gt;Twoją przeglądarką jest {user_agent}&lt;/p&gt;"
</pre>
            <hr>
            <a href="https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks">
                https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks
            </a><br>
            <a href="https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html">
                https://kronosapiens.github.io/blog/2014/08/14/understanding-contexts-in-flask.html
            </a><br>
            <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">
                https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
            </a>
        </p>
    </article>

    <article>
        <h1>Szablony</h1>

        <h2>Mechanizm szablonów Jinja2</h2>
        <p>
            Szablon to plik tekstowy odpowiedzi funkcji widoku. Domyślnie szablony są w
            folderze <em>templates</em>
<pre><i><u>file: templates/index.html</u></i>
&lt;h1&gt;Hello, World!&lt;/h1&gt;
</pre>
<pre><i><u>file: templates/user.html</u></i>
&lt;h1&gt;Hello, {{ name }}!&lt;/h1&gt;
</pre>
        </p>

        <h3>Renderowanie szablonów</h3>
<pre><i><u>file: hello.py</u></i>
from flask import <b>render_template</b>
&hellip;
@app.route('/')
def index():
    return <b>render_template('index.html')</b>
@app.route('/user/&lt;name&gt;')
def user(name):
    return <b>render_template('user.html', name=name)</b>
</pre>

        <h3>Zmienne</h3>
        <p>
            Jinja2 rozpoznaje zmienne dowolnego typu, nawet złożonego
<pre>
&lt;p&gt;Wartość <b>{{ myobj.somemethod() }}, {{ mylist[id] }}</b>&lt;/p&gt;
</pre>
        </p>
        <p>
            Zmienne można modyfikować za pomocą <em>filtrów</em>
<pre>
&lt;p&gt;Hello <b>{{ name|capitalize }}</b>&lt;/p&gt;
</pre>
            Lista wybranych filtrów
            <ul>
                <li><strong>safe</strong> &mdash; renderuje wartość bez interpretowania znaków modyfikacji; interpretuje znaczniki HTML</li>
                <li><strong>capitalize</strong> &mdash; zmienia pierwszy znak wartości na wielką literą, a pozostałe na małe</li>
                <li><strong>lower</strong> &mdash; zmienia tekst na małe litery</li>
                <li><strong>upper</strong> &mdash; zmienia tekst na duże litery</li>
                <li><strong>title</strong> &mdash; pierwsza litera każdego słowa zapisana jest wielką literą</li>
                <li><strong>trim</strong> &mdash; usuwa białe znaki z początku i końca</li>
                <li><strong>striptags</strong> &mdash; przed renderowaniem usuwa z wartości wszystkie znaczniki HTML</li>
                <li><a href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters">see doc</a></li>
            </ul>
        </p>

        <h3>Struktury sterujące</h3>
        <p>
            <u>Instrukcja warunkowa</u>
<pre>
{% if user %}
    Witaj {{ user }}!
{% else %}
    Witaj, nieznajomy!
{% endif %}
</pre>
            <u>Pętla <em>for</em></u>
<pre>
&lt;ul&gt;
    {% for comment in comments %}
        &lt;li&gt;{{ comment }}&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w tym samym pliku</u>
<pre>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}

&lt;ul&gt;
    {% for comment in comments %}
    {{ render_comment(comment) }}
    {% endfor %}
&lt;/ul&gt;
</pre>
            <u>Makro w osobnym pliku</u>
<pre><i><u>file: templates/macros.html</u></i>
{% macro render_comment(comment) %}
    &lt;li&gt;{{ comment }}&lt;/li&gt;
{% endmacro %}
</pre>
<pre><i><u>file: templates/index.html</u></i>
{% import 'macros.html' as macros %}
&lt;ul&gt;
{% for comment in comments %}
    {{ render_comment(comment) }}
{% endfor %}
&lt;/ul&gt;
</pre>
            <u>Wielokrotnie używany kod szablonu można zapisać w osobnym pliku i dołączać w innych miejscach</u>
<pre>
{% include 'common.html' %}
</pre>
            <u>Dziedziczenie szablonów</u><br>
            Szablon podstawowy
<pre><i><u>file: templates/base.html</u></i>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
{% block head %}
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{% block title %}{% endblock %} - Moja aplikacja&lt;/title&gt;
{% endblock %}
&lt;/head&gt;
&lt;body&gt;
    {% block body %}
    {% endblock %}
&lt;/body&gt;
&lt;/html&gt;
</pre>
            Szablon wywiedziony (dziedziczący) z szablonu podstawowego
<pre>
{% extends "tmp/base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    &lt;style&gt;
    &lt;/style&gt;
{% endblock %}
{% block body %}
&lt;h1&gt;Witaj, {{ user }}?&lt;/h1&gt;
{% endblock %}
</pre>
            Bloki mogą być zagnieżdżone. Funkcja <em>super()</em> odwołuje się do zawartości bloku w szablonie bazowym.
        </p>


        <h2>Integracja Bootstrap z Flask-Bootstrap</h2>
        <p>
            <a href="https://getbootstrap.com/">https://getbootstrap.com/</a><br>
            Instalacja w wirtualnym środowisku
            <code>
                (venv) $ pip install flask-bootstrap
            </code>
            Inicjalizacja rozszerzenia Flask-Bootstrap
<pre>
from flask_bootstrap import Bootstrap
&hellip;
bootstrap = Bootstrap(app)
</pre>
        </p>
        <p>
            Aplikacja uzyskuje dostęp do szablonu bazowego Bootstrap'a
<pre><i><u>file: templates/user.html</u></i>
{% extends "bootstrap/base.html" %}
{% block title %}My Title{% endblock %}
{% block navbar %}&hellip;{% endblock %}
{% block content %}&hellip;{% endblock %}
&lt;!-- Bootstrap definiuje również inne bloki  --&gt;
</pre>
        </p>
        <p>
            Aby nie nadpisać domyślnej zawartości bloków Bootstrapa, należy
            użyć <em>super()</em>
<pre>
{% extends "bootstrap/base.html" %}
{% block scripts %}
{{ super() }}
&lt;script type="text/javascript" src="my-script.js"&gt;&lt;/script&gt;
{% endblock %}
</pre>
        </p>


        <h2>Niestandardowe strony błędów</h2>
        <p>
            Obsługa przykładowych błędów
<pre>
@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('500.html'), 500
</pre>
        </p>
        <p>
            Aby nie powielać kodu, strony <em>404.html</em> i <em>500.html</em>
            mogą dziedziczyć z szablonu bazowego
            dla całego serwisu <em>template/base.html</em>, a ten z kolei powinien
            dziedziczyć z szablonu bazowego Bootstrapa <em>bootstrap/base.html</em>.
        </p>


        <h2>Łącza</h2>
        <p>
            Funkcja <em>url_for()</em> generuje adres URL na podstawie
            informacji przechowywanych w mapie adresów.
<pre>
url_for('index')  # '/'
url_for('index', _external=True)  # 'http://localhost:5000/'
url_for('user', name='janusz', _external=True)  # http://localhost:5000/user/janusz
url_for('user', name='admin', page=2, version=1)  # '/user/admin?page=2&version=1'
</pre>
        </p>


        <h2>Pliki statyczne</h2>
        <p>
            Flask domyślnie szuka plików statycznych w podkatalogu <em>/static/</em>.
            Przykładowo dodanie favicon
<pre><i><u>file: templates/base.html</u></i>
{% block head %}
{{ super() }}
&lt;link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}" type="image/x-icon"&gt;
{% endblock %}
</pre>
        </p>


        <h2>Lokalizowanie dat i czasu za pomocą pakietu <em>Flask-Moment</em></h2>
        <p>
            <strong>Flask-moment</strong>, to rozszerzenie, które integruje
            bibliotekę <em>Moment.js</em> z szablonami <em>Jinja2</em>. Do
            działania potrzebuje jeszcze pakietu <em>jQuery.js</em>, który
            dostarcza choćby Bootstrap.
        </p>
        <p>
            Instalacja pakietu <a href="https://momentjs.com">Flask-moment</a>
            <code>(venv) $ pip install flask-moment</code>
        </p>
        <p>
            Inicjowanie pakietu
<pre>
from flask_moment import Moment
app = Flask(__name__)
moment = Moment(app)
</pre>
        </p>
        <p>
            Importowanie biblioteki <em>Moment.js</em> do szablonu.
            <em>local('pl')</em> określa regionalizację.
            Pakiet <em>Flask-moment</em> udostępnia szablonom obiekt <em>moment</em>
            umożliwiający pracę ze znacznikami czasu.
<pre><i><u>file: templates/base.html</u></i>
{% block scripts %}
{{ super() }}
{{ moment.include_moment() }}
{{ moment.locale('pl')}}
{% endblock %}
</pre>
        </p>
        <p>
            Czas uniwersalny UTC jest przekazywany do szablonu
<pre>
from datetime import datetime, UTC
@app.route('/time')
def show_time():
    return render_template('time.html', current_time=datetime.now(UTC))
</pre>
        a w szablonie jest renderowany na czas lokalny
<pre>
&lt;p&gt;Lokalna data i czas: {{ moment(current_time).format('LLL') }}.&lt;/p&gt;
&lt;p&gt;To było {{ moment(current_time).fromNow(refresh=True) }}&lt;/p&gt;
</pre>
        </p>
        <p>
            <a href="https://blog.miguelgrinberg.com/post/it-s-time-for-a-change-datetime-utcnow-is-now-deprecated">
                naive datetime object
            </a><br>
            <a href="https://en.wikipedia.org/wiki/ISO_3166-1">
                kody regionalizacji
            </a><br>
            <a href="https://momentjs.com/docs/#/displaying/">
                Moment.js formatowanie
            </a>
        </p>

    </article>

    <article>
        <h1>Formularze internetowe</h1>
        <p>
            <a href="https://en.wikipedia.org/wiki/HTML_form">
                https://en.wikipedia.org/wiki/HTML_form
            </a><br>
            <a href="https://flask-wtf.readthedocs.io/en/1.2.x/">
                https://flask-wtf.readthedocs.io/en/1.2.x/
            </a><br>
            <a href="https://wtforms.readthedocs.io/en/3.1.x/">
                https://wtforms.readthedocs.io/en/3.1.x/
            </a>
        </p>


        <h2>Konfiguracja</h2>
        <p>
            Instalacja Flask-WTF oraz jego zależności
            <code>
                (venv) $ pip install flask-wtf
            </code>
        </p>
        <p>
            Wymagany przez <em>Flask-WTF</em> tajny klucz
<pre><i><u>file: hello.py</u></i>
app.config['SECRET_KEY'] = 'trudny do odgadnięcia ciąg znaków'
</pre>
        Bardziej bezpieczne przechowywanie klucza
        <a href="#Rozdział_7">Rozdział 7</a>
        </p>


        <h2>Klasy formularzy</h2>
        <p>
            Definicja klasy formularza
<pre><i><u>file: hello.py</u></i>
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired

class NameForm(FlaskForm):
    name = StringField('Jak masz na imię?', validators=[DataRequired()])
    submit = SubmitField('Wyślij')
</pre>
        </p>


        <h2>Renderowanie formularzy HTML</h2>
        <p>
            Prosty formularz
<pre>
&lt;form method="POST"&gt;
    {{ form.hidden_tag() }}
    {{ form.name.label }} {{ form.name() }}
    {{ form.submit() }}
&lt;/form&gt;
</pre>
        </p>
        <p>
            lub z pomocą Bootstrapa
<pre>
{% import "bootstrap/wtf.html" as wtf %}
{{ wtf.quick_form(form) }}
</pre>
        </p>


        <h2>Obsługa formularzy w funkcjach widoku</h2>
        <p>
            W dekoratorze drugi parametr <em>methods</em> to lista obsługiwanych przez widok
            metod. <em>form.validate_on_submit()</em> jest <em>True</em> jeśli ostatnim
            żądaniem był <em>POST</em> (w formularzu <em>form</em> został naciśnięty przycisk
            <em>Wyślij</em>)
<pre><i><u>file: hello.py</u></i>
@app.route('/forms', methods=['GET', 'POST'])
def forms():
    name = None
    form = NameForm()
    if form.validate_on_submit():  # Czy POST?
        name = form.name.data
        form.name.data = ''  # puste pole formularza
    return render_template('forms.html', form=form, name=name)
</pre>
        <em>form.name.data</em> przechowuje dane wpisane w formularzu.
        </p>


        <h2>Przekierowania i sesja użytkownika</h2>
        <p>
            Wzorzec projektowy <strong>Post/Redirect/Get</strong> &mdash;
            unikanie ponownego wysyłania formularza metodą POST, np. w wyniku
            odświerzenia strony oraz przenoszenie danych sesji po zakończeniu
            obsługi żądania <em>POST</em> w wyniku przekierowania.
<pre><i><u>file: hello.py</u></i>
from flask import session, redirect, url_for
app.route('/forms2', methods=['GET', 'POST'])
def forms2():
    form = NameForm()
    if form.validate_on_submit():  # Czy POST?
        session['name'] = form.name.data
        return redirect(url_for('forms2'))
    return render_template('forms.html', form=form, name=session.get('name'))
</pre>

        </p>


        <h2>Wyświetlanie komunikatów</h2>
        <p>
            Flask udostępnia funkcję <em>flash()</em>, która zbiera komunikaty
<pre><i><u>file: hello.py</u></i>
from flask import session, redirect, url_for, flash
@app.route('/forms3', methods=['GET', 'POST'])
def forms3():
    form = NameForm()
    if form.validate_on_submit():  # Czy POST?
        old_name = session.get('name')
        if old_name is not None and old_name != form.name.data:
            flash('Wygląda na to, że teraz nazywasz się inaczej!')
        session['name'] = form.name.data
        return redirect(url_for('forms3'))
    return render_template('forms.html', form=form, name=session.get('name'))
</pre>
        </p>
        <p>
            Następnie w szablonie można odczytać te komunikaty przez metodę
            <em>get_flashed_messages()</em>
<pre><i><u>file: templates/base.html</u></i>
{% block content %}
&lt;div class="container"&gt;
    {% for message in get_flashed_messages() %}
    &lt;div class="alert alert-warning"&gt;
        &lt;button type="button" class="close" data-dismiss="alert"&gt;&times;&lt;/button&gt;
        {{ message }}
    &lt;/div&gt;
    {% endfor %}

    {% block page_content %}{% endblock %}
&lt;/div&gt;
{% endblock %}
</pre>
            Wiadomości pobrane przez metodę <em>get_flashed_messages()</em> nie zostaną
            zwrócone przy następnym wywołaniu tej funkcji, więc wyskakujące komunikaty
            pojawią się raz, a następnie są niewyświetlane.
        </p>
    </article>



    <article>
        <h1>Bazy danych</h1>
        <p>
            <a href="https://pl.wikipedia.org/wiki/ACID">
                ACID
            </a><br>
            <a href="https://pl.wikipedia.org/wiki/Mapowanie_obiektowo-relacyjne">
                ORM
            </a><br>
            <a href="https://flask-sqlalchemy.palletsprojects.com/en/3.1.x/">
                flask-sqlalchemy
            </a><br>
            <a href="https://www.sqlalchemy.org/">
                https://www.sqlalchemy.org/
            </a>
        </p>

        <h2>Zarządzanie bazą danych za pomocą Flask-SQLAlchemy</h2>
        <p>
            Instalacja w wirtualnym środowisku
            <code>(venv) $ pip install flask-sqlalchemy</code>
        </p>
        <p>
            Konfiguracja bazy danych
<pre><i><u>file: hello.py</u></i>
import os
from flask_sqlalchemy import SQLAlchemy
basedir = os.path.abspath(os.path.dirname(__file__))
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
</pre>
        </p>

        <h2>Definicja modelu</h2>
        <p>
<pre>
class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)

    def __repr__(self) -&gt; str:
        return '&lt;Role %r&gt;' % self.name


class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)

    def __repr__(self) -&gt; str:
        return '&lt;User %r&gt;' % self.username
</pre>
        <em>__tablename__</em> &mdash; nazwa tabeli w bazie danych<br>
        <em>id, name, username</em> &mdash; atrybuty modelu jako obiekty klasy<br>
        <em>db.Column(typ_kolumny_db, opcje_konfiguracji)</em><br>
        Flask-SQLAlchemy wymaga, aby wszystkie modele definiowały kolumnę
        klucza głównego, która zazwyczaj otrzymuje nazwę <em>id</em>.
        </p>

        <h2>Relacje</h2>
        <p>
            Relacje w modelach baz danych na przykładzie relacji
            <strong>1&rightarrow;N</strong>
<pre>
class Role(db.Model):
    &hellip;
    users = db.relationship('User', backref='role')

class User(db.Model):
    &hellip;
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
</pre>
        </p>

        <h2>Operacje na bazach danych</h2>
        <h3>Tworzenie tabel</h3>
        <p>
            Tworzenie bazy danych na podstawie klas modeli
            <code>(venv) $ flask shell</code>
            <code>&gt;&gt;&gt; from hello import db</code>
            <code>&gt;&gt;&gt; db.create_all()</code>
        </p>
        <p>
            Aktualizacja istniejące bazy, gdy nastąpi zmiana modeli.
            Najpierw usuwamy wszystkie tabele, a potem odtwarzamy je
            na nowo na podstawie subklas klasy <em>db.Model</em>
            <code>&gt;&gt;&gt; db.drop_all()</code>
            <code>&gt;&gt;&gt; db.create_all()</code>
            Niestety ta metoda również usuwa wszystkie dane.
        </p>
        <h3>Wstawianie wierszy</h3>
        <p>
            Konstruktory modeli przyjmują wartości początkowe atrybutów modelu
            jako argumenty słów kluczowych
            <code>&gt;&gt;&gt; from hello import Role, User</code>
            <code>&gt;&gt;&gt; admin_role = Role(name='Admin')</code>
            <code>&gt;&gt;&gt; user_john = User(username='jan', role=admin_role)</code>
            Atrybut <em>id</em> jest uzupełniany automatycznie, ale dopiero po
            zapisaniu w bazie danych. Aby przygotować obiekty do zapisania w
            bazie danych, należy je dodać do sesji
            <code>&gt;&gt;&gt; db.session.add(admin_role)</code>
            <code>&gt;&gt;&gt; db.session.add(user_john)</code>
            lub bardziej zwięźle
            <code>&gt;&gt;&gt; db.session.add_all([admin_role, user_john])</code>
            Zapisać do bazy, to wydać polecenie
            <code>&gt;&gt;&gt; db.session.commit()</code>
            Cofanie sesji bazy danych
            <code>&gt;&gt;&gt; db.session.rollback()</code>
        </p>
        <h3>Modyfikowanie wierszy</h3>
        <p>
            Metoda <em>session.add()</em> może być użyta do aktualizacji
            modeli
            <code>&gt;&gt;&gt; admin_role.name = 'Administrator'</code>
            <code>&gt;&gt;&gt; db.session.add(admin_role)</code>
            <code>&gt;&gt;&gt; db.session.commit()</code>
        </p>
        <h3>Usuwanie wierszy</h3>
        <p>
            Przykład usuwania roli <em>Moderator</em> z bazy danych
            <code>&gt;&gt;&gt; db.session.delete(mod_role)</code>
            <code>&gt;&gt;&gt; db.session.commit()</code>
        </p>
        <h3>Zapytanie o wiersze</h3>
        <p>
            W każdej klasie modelu istnieje obiekt zapytania <em>query</em>.
            Metoda <em>all()</em> zwraca całą zawartość tabeli powiązanej z modelem
            <code>&gt;&gt;&gt; Role.query.all()</code>
            <code>&gt;&gt;&gt; User.query.all()</code>
            Można filtrować wynik (wszyscy użytkownicy z rolą <em>Admin</em>)
            <code>&gt;&gt;&gt; User.query.filter_by(role=admin_role).all()</code>
            Przejrzenie kodu zapytania SQL, należy użyć konwersji obiektu
            zapytania na ciąg znaków
            <code>&gt;&gt;&gt; str(User.query.filter_by(role=user_role))</code>
        </p>
</body>
</html>

